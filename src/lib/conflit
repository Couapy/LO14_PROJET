#!/bin/bash


### Revoir la mise en page [WARN] [INFO] [ERR] (optionnel)


### $1 chemin absolu du fichier local créant conflit
### $2 chemin absolu du fichier distant créant conflit
### $3 cas du conflit
# Différent cas : (le numéro indiquer correspond à la valeur de $3 dans le script principal)
#     1 - Les deux fichiers ont été modifié depuis la dernière synchro
#     2 - Un fichier à le même nom qu'un répertoire
#     3 - Fichier modifié en local et supprimé en distant [!!] ici $2 correspond au chemin absolu ou se trouvé le fichié supprimé distant
#     4 - Fichier modifié en distant et supprimé en local [!!] ici $1 correspond au chemin absolu ou se trouvé le fichié supprimé distant
#     5 - Deux Fichiers ont été créés avec le même nom

### $1, nom du fichier qui pose problème
### $2 type de conflit

### Déclaration d'un nouveau nom
# $1 chemin absolu du fichier
function name_change {
    chemin=$(dirname $1)
    continuer=1
    while [ $continuer -eq 1 ];
    do
        echo "Nouveau nom : "
        read new_name
        if [ -e $chemin/$new_name ];
        then
            echo "[ERR] Ce nom est déjà attribué à un autre fichier ou répertoire. \n"
        else
            continuer=0
        fi
    done
}

### Ecrase le fichier se trouvant sur le pc par celui de la machine distante (cas 1)
# $1 chemin vers le fichier qui va être écrasé
# $2 chemin vers le fichier en qui va être garder
# $3 phrase prompt
function delete {
    path_delete=$(dirname $1)
    path_save=$(dirname $2)
    name=$(basename $2)
    continuer=1
    while [ $continuer -eq 1 ];
    do
        # On affiche la demande et on lit le choix de l'utilisateur
        echo $3
        read verification
        if [ "$verification" == "oui" ];
        then
            cp $path_save/$name $path_delete/$name
            resolu=0
            continuer=0
        elif [ "$verification" == "non" ];
        then
            continuer=0
            resolu=1
        else
            echo "[ERR] Entrée invalide"
        fi 
    done

    return $resolu   
}

### Sauvegarde des deux fichier en changeant le nom de l'un d'eux (cas 1)
# $1 chemin vers le fichier en conflit local
# $2 chemin vers le fichier en conflit distant
function double_save {
    new_name=$(name_change $1) # On renomme obligatoirement le fichier local
    file_path_local=$(dirname $1) # chemin vers le fichier > /path/dir/sync
    file_name=$(basename $1) # nom du fichier:  le même pour les deux puisque conflit
    file_path_distant=$(dirname $2) # chemin vers le fichier > /path/dir/sync
    
    mv $file_path_local/$file_name $file_path_local/$new_name ### changement de nom dans l'ordi
    echo "[INFO] Changement de nom réalisé"
    cp $file_path_local/$new_name $file_path_distant/$new_name ### path+new_name pour en faire la copie dans le distant
    cp $file_path_distant/$file_name $file_path_local/$file_name
    echo "[INFO] Synchronisation des fichiers réalisés"

    return 0
}

### Changement du nom du fichier ou repertoire (cas 2)
# $1 chemin vers le fichier ou répertoire dont on souhaite changer le nom
# $2 Nouveau nom du fichier
function file_name_change {
    new_name=$2
    file_name=$(basename $1) # nom du fichier:  le même pour les deux puisque conflit
    path_change_file=$(dirname $1) # chemin vers le fichier > /path/dir/sync

    mv $path_change_file/$file_name $path_change_file/$new_name
}

### Traitement des cas 3 et 4 qui abouti soit à la sauvegarde du fichier soit à sa supression
# $1 chemin vers le fichier existant
# $2 chemin vers le repertoire où se trouvait le fichier qui a été supprimé
# $3 prompt en fonction du traitement du cas 3 ou 4
function modif_ou_supp {
    ### Proposition de choix pour l'utilisateur
    name_file=$(basename $1)
    file_path_exist=$(dirname $1)

    echo "$name_file $3"
    echo "Que souhaitez vous faire :"
    echo " 1 - Garder et synchroniser le fichier modifié"
    echo " 2 - Supprimer le fichier "
    read choix

    if [ $choix -eq 1 ];
    then
        file_path_supp=$2
        
        cp $file_path_exist/$name_file $file_path_supp/$name_file
        echo "[INFO] Copie réalisée."
    elif [ $choix -eq "2" ];
    then
        continuer=1
        while [ $continuer -eq 1 ];
        do 
            echo "[WARN] Etes-vous sûr de vouloir supprimer $name_file : (oui/non)"
            read verification
            if [ "$verification" == "oui" ];
            then 
                rm $file_path_exist/$name_file
                echo "[INFO] Fichier supprimé"
                resolu=0
                continuer=0    
            elif [ "$verification" == "non" ];
            then
                continuer=0
                resolu=1
            else
                echo "[ERR] Entrée invalide"
            fi 
        done
    fi

    return $resolu
}

### Fonction gérant le cas 1
function cas_1 {
    name_file=$(basename $1)
    resolu=1

    ### Proposition de choix pour utilisateur
    echo "[INFO] Les deux fichiers $name_file ont été crée ou modifié depuis la dernière synchronisation."
    echo "Que voulez vous faire :"
    echo " 1 - Donner un autre nom à la version présente sur ce pc"
    echo " 2 - Ecraser la version disponible sur le pc distant"
    echo " 3 - Ecraser le fichier disponible sur ce pc "
    read choix
    phrase_supp_distant="[WARN] Etes-vous sûr de vouloir écraser la version disponible sur le pc distant (oui / non) :"
    phrase_supp_local="[WARN] Etes-vous sûr de vouloir écraser la version disponible sur ce pc (oui / non) :"
    ### Choix : on garde les deux donc on change un des noms
    if [ $choix -eq 1 ];
    then 
        resolu=$(double_save $1 $2)
    ### On ecrase sur le pc distant
    elif [ $choix -eq 2 ];
    then
        resolu=$(delete $2 $1 $phrase_supp_distant)
    ### On écrase sur le pc qui lance le sync
    elif [ $choix -eq 3 ];
    then
        resolu=$(delete $1 $2 $phrase_supp_local)
    else
        echo "[ERR]Choix non valide."
    fi
    echo "[INFO] Conflit corrigé"

    return $resolu
}

### Fonction gérant le cas 2
function cas_2 {
    name_file=$(basename $1)
    new_name=""

    ### Proposition de choix pour l'utilisateur
    echo "${name_file} est à la fois un ficher et un répertoire. Changer le nom du :"
    echo " 1 - fichier"
    echo " 2 - répertoire"
    read choix
    name_change $1

    if [ -d $1 ];
    then
        dossier=$1
        fichier=$2
    else
        dossier=$2
        fichier=$1
    fi

    if [ "$choix" == "1" ];
    then
        file_name_change $fichier $new_name
    elif [ "$choix" == "2" ];
    then
        file_name_change $dossier $new_name
    else
        echo "[ERR] Choix invalide!"
    fi

    return 1
}

### Fonction gérant le cas 3
function cas_3 {
    prompt="se trouve sur le pc local et a été supprimé sur le pc distant"
    resolu=$(modif_ou_supp $1 $2 $prompt)
    echo "[INFO] Conflit corrigé"

    return $resolu   
}

### Fonction gérant le cas 4
function cas_4 {
    prompt="se trouve sur le pc distant et a été supprimé sur le pc local"
    resolu=$(modif_ou_supp $2 $1 $prompt)
    echo "[INFO] Conflit corrigé"

    return $resolu
}

### Fonction gérant le cas 5
function cas_5 {
    md5_local=$(md5sum $1 | cut -d' ' -f1)
    md5_distant=$(md5sum $2 | cut -d' ' -f1)
    if [ "$md5_local" == "$md5_distant" ];
    then
        echo "[INFO] Il n'y pas de conflit"
    else
        ### On revient au cas 1, on doit soit garder les deux en changeant un des nom soit en supprimer 1
        conflit $1 $2 1
    fi
    resolu=0

    return $resolu
}

### Main script
# $1 chemin vers le fichier en conflit local
# $2 chemin vers le fichier en conflit distant
# => Dans le cas 3 et 4 :  $1 (cas 4) ou $2 (cas 3) correspond juste au chemin absolu vers le repertoire où le fichier a été supprimé
# $3 type de conflit
function conflit {
    resolu=0
    numero_conflit=$3
    while [ $resolu -eq 0 ];
    do
        ### Selection du type de conflit : choix 1 --> Les deux fichiers ont été modifié depuis la dernière synchro.
        if [ $numero_conflit -eq 1 ]; then
            cas_1 $1 $2
        ### Sélection du type de conflit : choix 2 --> un fichier à le même nom qu'un répertoire
        elif [ $numero_conflit -eq 2 ]; then
            cas_2 $1 $2
        ### Sélection du type de conflit : choix 3 -->  Si le fichier a été modifié en local et supprimer en distant
        elif [ $numero_conflit -eq 3 ]; then
            cas_3 $1 $2
        ### Sélection du type de conflit : choix 4 -->  Si le fichier a été modifié en distant et supprimer en local
        elif [ $numero_conflit -eq 4 ]; then
            cas_4 $1 $2
        ### Sélection du type de conflit : choix 5 -->  Deux fichier ont été crée avec le même nom
        elif [ $numero_conflit -eq 5 ]; then
            cas_5 $1 $2
        fi
        resolu=$?
    done
}

conflit $2 $3 $4